
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>PGF_equation_generator</title><meta name="generator" content="MATLAB 8.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-03-25"><meta name="DC.source" content="PGF_equation_generator.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">SIR-ODE generation for hyperstub configuration model networks</a></li><li><a href="#3">Example usage</a></li><li><a href="#4">Initialisation</a></li><li><a href="#5">PGF generation</a></li><li><a href="#6">Code generation</a></li><li><a href="#8">State transition matrix generation</a></li></ul></div><h2>SIR-ODE generation for hyperstub configuration model networks<a name="1"></a></h2><pre class="codeinput"><span class="keyword">function</span> PGF_equation_generator(lambda, varargin)
</pre><pre class="codeinput"><span class="comment">% ------------------------------------------------------------------------</span>
<span class="comment">%                    http://arxiv.org/abs/1405.6234</span>
<span class="comment">% ------------------------------------------------------------------------</span>
<span class="comment">% The following code will generate generating function bassed,</span>
<span class="comment">% deterministic ODEs and corresponding solutions. The solutions include</span>
<span class="comment">% population level averages for the three respective compartments that may</span>
<span class="comment">% be compared to averages taken from simulation. Written by Martin Ritchie,</span>
<span class="comment">% University of Sussex, 2014.</span>
<span class="comment">% ------------------------------ output ----------------------------------</span>
<span class="comment">% lambda:   a vector containing the desired expected subgraph count per</span>
<span class="comment">%           node, lambda(i) corresponds to the ith varargin,</span>
<span class="comment">% varargin: Input is a string, where each string is the name assoicated the</span>
<span class="comment">%           desired subgraph. Separate different subgraphs names with</span>
<span class="comment">%           commas. Input subgraphs in the same order as thier given</span>
<span class="comment">%           expectations in lambda (example subgraphs are given in</span>
<span class="comment">%           subgraphs.mat).</span>
<span class="comment">% ------------------------- Generated files ------------------------------</span>
<span class="comment">% x_alpha.m (one per subgraph type),</span>
<span class="comment">% x_equations.m (one per subgraph type),</span>
<span class="comment">% PGF_jacobian.m (one for the whole system)</span>
<span class="comment">% PGF_hessian.m (one for the whole system)</span>
<span class="comment">% func.m (one for the whole system)</span>
<span class="comment">%</span>
<span class="comment">% # dependencies: combinator.m, inf_neighbors.m, subgraphs.mat</span>
<span class="comment">% and MATLAB's symbolic toolbox.</span>
</pre><h2>Example usage<a name="3"></a></h2><div><ol><li>The following will generate and solve ODEs for a Poisson random network with parameter, lambda = 4:</li></ol></div><p>PGF_equation_generator(4, 'C2'); [S, I, R, T] = episolve();</p><p>Where 'C2' denotes a complete subgraph of two nodes, i.e. a line, that will be loaded from subgraphs.mat. Load subgraphs.mat to see what subgraphs are available or create your own.</p><div><ol><li>The following will generate and solve ODEs for a network where lines and triangles are Poisson distributed with parameters, lambda = [2 2] respectively:</li></ol></div><p>PGF_equation_generator([2 2], 'C2', 'C3'); [S, I, R, T] = episolve(); Note that the epidemic parameters are controlled from within this function.</p><h2>Initialisation<a name="4"></a></h2><pre class="codeinput"><span class="keyword">global</span> eps tau gamma Tend PGF_Jacobian_1 sg node_positions alpha
load(<span class="string">'subgraphs'</span>,varargin{:});
<span class="comment">% Note that the epidemic parameters are controlled from within this</span>
<span class="comment">% function.</span>
<span class="comment">% eps: fraction of inital infected.</span>
eps = 1/10000;
<span class="comment">%</span>
Tend = 15;
<span class="comment">% tau: per link rate of infection.</span>
tau = 1;
<span class="comment">% gamma: rate of recovery.</span>
gamma  = 1;
<span class="comment">% node_positions: number of positions in the system.</span>
node_positions = 0;
<span class="comment">% sg: a cell array where each entry contains the adjacency matrix of the</span>
<span class="comment">%     subgraphs specified by varargin.</span>
<span class="keyword">for</span> i = 1:length(varargin)
    sg{i} = eval(varargin{i});
    node_positions = node_positions + length(sg{i});
<span class="keyword">end</span>
</pre><h2>PGF generation<a name="5"></a></h2><p>The following utilises MATLAB's symbolic toolbox. It symbolically generates and compute the Jacobian and Hessian of the PGF that generates the networks subgraph degree distribution. In this implementation each subgraph is Poisson distributed. ------------------------------------------------------------------------</p><pre class="codeinput"><span class="comment">%------------------------ Standard Poisson PGF ----------------------------</span>

<span class="comment">% The following generates the PGF.</span>
X = sym(<span class="string">'X'</span>, [1 node_positions]);
PGF = 1;
<span class="keyword">for</span> i = 1:length(sg)
    m(i) = length(sg{i});
    PGF = PGF*exp(lambda(i)*m(i)^(-1) * (sum(X(1:m(i)))-m(i)));
    X(1:m(i)) = [];
<span class="keyword">end</span>
X = sym(<span class="string">'X'</span>, [1 node_positions]);

<span class="comment">% It is inefficient to keep it in symbolic form. The following converts</span>
<span class="comment">% the symbolic forms of the Jacobian and Hessian of the PGF into MATLAB</span>
<span class="comment">% functions.</span>

PGF_Jacobians = jacobian(PGF,X);
PGF_Hessians = hessian(PGF,X);
<span class="comment">% Convert the symbolic Jacobian and Hessian to .m MATLAB functions.</span>
matlabFunction(PGF_Hessians, <span class="string">'file'</span>, <span class="string">'PGF_Hessian'</span>,<span class="string">'vars'</span>, X);
matlabFunction(PGF_Jacobians, <span class="string">'file'</span>, <span class="string">'PGF_Jacobian'</span>,<span class="string">'vars'</span>, X);
clear <span class="string">PGF_Jacobians</span> <span class="string">PGF_Hessians</span>

<span class="comment">% % state_count(i):    The number of states associated with subraph i.</span>
<span class="comment">% % subgraph_index(i): The first position index associated with each subgraph.</span>
state_count = zeros(length(varargin),1);
subgraph_index = zeros(length(varargin),1);
<span class="keyword">for</span> i = 1:length(varargin)
    <span class="keyword">if</span> i ==1
        subgraph_index(i) = 1;
    <span class="keyword">else</span>
        subgraph_index(i) = subgraph_index(i-1) + length(sg{i-1});
    <span class="keyword">end</span>
    state_count(i) = 3^length(sg{i});
<span class="keyword">end</span>
<span class="comment">% The total number of ODEs:</span>
system_size = (sum(state_count) + node_positions + 2);
<span class="comment">% PGF_Jacobian_1: Jacobian of the PGF evaluated at 1.</span>
in = num2cell(ones(1,node_positions));
PGF_Jacobian_1 = PGF_Jacobian(in{:});
</pre><pre class="codeoutput">Error using mupadmex
Error in MuPAD command: The number of columns does not match. [(Dom::Matrix(Dom::ExpressionField()))::mkSparse]

Error in sym/jacobian (line 34)
Jsym = mupadmex('symobj::jacobian',F.s,x.s);

Error in PGF_equation_generator (line 91)
PGF_Jacobians = jacobian(PGF,X);
</pre><h2>Code generation<a name="6"></a></h2><p>The following generates three different m-files: # x_alpha.m: a function file that returns initial conditions for the subgraph x, # x_equations: a function file that returns state equations for the subgraph x, # func.m: the function that is passed to ODE45 for integration. alpha: is a vector of initial conditions that is eventually passed to ode 45. It needs to be initialised outside of the following loop, within which the remaining initial conditions are generated and appended to alpha.</p><pre class="codeinput">alpha = zeros(1,(node_positions));
<span class="comment">% Survivor function (theta) initial conditions:</span>
<span class="keyword">for</span> i = 1:node_positions
    <span class="keyword">if</span> PGF_Jacobian_1(i)~=0
        alpha(i) = 1;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% ii cycles through each subgraph generating x_equations.m followed by</span>
<span class="comment">% x_alpha.m</span>
<span class="keyword">for</span> ii = 1:length(varargin)
    <span class="comment">% states: a matrix containing all possible states of g.</span>
    states = combinator(3,length(sg{ii}),<span class="string">'p'</span>,<span class="string">'r'</span>)-2;
    <span class="comment">% trans_matrix: creates the state transition matrix for g.</span>
    transition_matrix = trans_matrix(sg{ii},subgraph_index(ii),states);

    <span class="comment">% the following creates a matlab function file that corresponds to</span>
    <span class="comment">% the state equations for subgraph g.</span>
    flux_name = sprintf(<span class="string">'%s_equations.m'</span>,varargin{ii});
    fid = fopen(flux_name,<span class="string">'w'</span>);
    ltm = length(transition_matrix);
    fprintf(fid,<span class="string">'function [dy] = %s_equations(y) \n \n global tau gamma Delta M \n D = Delta; \n \n '</span>,varargin{ii});
    <span class="keyword">for</span> i = 1:ltm
        <span class="keyword">for</span> k = 1:length(sg{ii})
            <span class="keyword">switch</span> states(i,k)
                <span class="keyword">case</span> -1
                    s(k) = <span class="string">'S'</span>;
                <span class="keyword">case</span> 0
                    s(k) = <span class="string">'I'</span>;
                <span class="keyword">case</span> 1
                    s(k) = <span class="string">'R'</span>;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        fprintf(fid, <span class="string">'  %% %s \n '</span>, s);
        fprintf(fid,<span class="string">'dy(%d) = '</span>, i);
        <span class="keyword">for</span> j = 1:ltm
            <span class="keyword">if</span> ~isempty(transition_matrix{i,j})
                <span class="keyword">if</span> transition_matrix{i,j}~=0
                    fprintf(fid,<span class="string">' - y(%d)*(%s)'</span>, [i transition_matrix{i,j}]);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="keyword">if</span> ~isempty(transition_matrix{j,i})
                <span class="keyword">if</span> transition_matrix{j,i}~=0
                    fprintf(fid,<span class="string">' + y(%d)*(%s)'</span>, [j transition_matrix{j,i}]);
                <span class="keyword">end</span>
            <span class="keyword">end</span>

        <span class="keyword">end</span>
        fprintf(fid,<span class="string">';\n \n'</span>);
    <span class="keyword">end</span>
    fprintf(fid,<span class="string">'end'</span>);
    fclose(fid);

    <span class="comment">% Initial conditions: the following generates x_alpha.m, a matlab</span>
    <span class="comment">% function file that returns a vector of initial conditions for subgraph</span>
    <span class="comment">% x.</span>

    alpha_name = sprintf(<span class="string">'%s_alpha.m'</span>,varargin{ii});
    fid = fopen(alpha_name,<span class="string">'w'</span>);
    ltm = length(transition_matrix);
    fprintf(fid,<span class="string">'function [initial] = %s_alpha \n \n global eps PGF_Jacobian_1 \n'</span>,varargin{ii});
    fprintf(fid,<span class="string">'initial = zeros(1,%d); \n'</span>, ltm);
    fprintf(fid,<span class="string">'if PGF_Jacobian_1(%d)==0 \n'</span>, subgraph_index(ii));
    fprintf(fid,<span class="string">'\t return \n'</span>);
    fprintf(fid, <span class="string">'else \n'</span>);
    <span class="keyword">for</span> i = 1:ltm
        <span class="keyword">if</span> isempty(find(states(i,:)==1))
            s_count = 0;
            i_count = 0;
            r_count = 0;
            <span class="keyword">for</span> k = 1:length(sg{ii})
                <span class="keyword">switch</span> states(i,k)
                    <span class="keyword">case</span> -1
                        s_count = s_count + 1;
                    <span class="keyword">case</span> 0
                        i_count = i_count + 1;
                    <span class="keyword">case</span> 1
                        r_count = r_count + 1;
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> s_count == length(sg{ii})
                fprintf(fid,<span class="string">'initial(%d) = (1-eps)*PGF_Jacobian_1(%d); \n'</span>, [i subgraph_index(ii)]);
            <span class="keyword">elseif</span> i_count &gt;= 2
                fprintf(fid,<span class="string">'initial(%d) = 0; \n'</span>, i);
            <span class="keyword">elseif</span> i_count == 1
                fprintf(fid,<span class="string">'initial(%d) = eps*PGF_Jacobian_1(%d); \n'</span>, [i subgraph_index(ii)]);
            <span class="keyword">else</span>
                fprintf(fid,<span class="string">'initial(%d) =0; \n'</span>, [i]);
            <span class="keyword">end</span>

        <span class="keyword">end</span>
    <span class="keyword">end</span>
    fprintf(fid, <span class="string">'end \n'</span>);
    fprintf(fid,<span class="string">'end'</span>);
    fclose(fid);
    innit_name{ii} = sprintf(<span class="string">'%s_alpha'</span>,varargin{ii});
    alpha(end+1:end + 3^length(sg{ii})) = feval(innit_name{ii});
<span class="keyword">end</span>
<span class="comment">% I_0</span>
alpha(end+1) = eps;
<span class="comment">% R_0</span>
alpha(end+1) = 0;




<span class="comment">% Generation of func.m: func.m is the ODE function that is passed to ODE45</span>
<span class="comment">% along with the vector of initial conditions, 'alpha'.</span>
fid=fopen(<span class="string">'func.m'</span>,<span class="string">'w'</span>);
fprintf(fid,<span class="string">'function dy = func(~,y) \n \n'</span>);
fprintf(fid,<span class="string">'global tau gamma Delta M PGF_Jacobian_1 \n'</span>);
fprintf(fid,<span class="string">'T  = zeros(1,%d); \n '</span>,node_positions);
fprintf(fid,<span class="string">'dy = zeros(%d,1); \n \n'</span>,system_size);

<span class="keyword">for</span> i = 1:node_positions
    <span class="keyword">if</span> i==1
        fprintf(fid, <span class="string">'PGF_Jacobian_theta  = PGF_Jacobian(y(%d),'</span>, i);
    <span class="keyword">elseif</span> i==node_positions
        fprintf(fid, <span class="string">'y(%d)); \n'</span>, i);
    <span class="keyword">else</span>
        fprintf(fid, <span class="string">'y(%d),'</span>, i);
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">for</span> i = 1:node_positions
    <span class="keyword">if</span> i==1
        fprintf(fid, <span class="string">'PGF_Hessian_theta  = PGF_Hessian(y(%d),'</span>, i);
    <span class="keyword">elseif</span> i==node_positions
        fprintf(fid, <span class="string">'y(%d)); \n'</span>, i);
    <span class="keyword">else</span>
        fprintf(fid, <span class="string">'y(%d),'</span>, i);
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% For loop that generates susceptible excess degree matrix, delta:</span>
fprintf(fid, <span class="string">'for i = 1:%d \n'</span>, node_positions);
fprintf(fid, <span class="string">' \t M(i) = y(i)*PGF_Jacobian_theta(i); \n'</span>);
fprintf(fid, <span class="string">'\t for  j = 1:%d \n'</span>,node_positions);
fprintf(fid, <span class="string">'\t\t if PGF_Jacobian_theta(i)==0 \n'</span>);
fprintf(fid, <span class="string">'\t\t\t delta(i,j)=0; \n'</span>);
fprintf(fid, <span class="string">'\t\t else \n'</span>);
fprintf(fid, <span class="string">'\t\t\t delta(i,j) = y(j)*PGF_Hessian_theta(i,j)/PGF_Jacobian_theta(i); \n'</span>);
fprintf(fid, <span class="string">'\t\t end \n'</span>);
fprintf(fid, <span class="string">'\t end \n'</span>);
fprintf(fid, <span class="string">' end \n'</span>);

<span class="comment">% T(i) contains the rate of infection received by node i. The following</span>
<span class="comment">% generates T(i) for each corner. If there are 2 graplets composed of a</span>
<span class="comment">% total of 10 corners then dim(T) = [1, 10].</span>
T_count = 1;
<span class="keyword">for</span> kk = 1:length(sg)
    <span class="keyword">if</span> kk==3
        kk = 3;
    <span class="keyword">end</span>
    state_card = length(sg{kk});
    <span class="keyword">for</span> k = 1:state_card
        states = combinator(3,length(sg{kk}),<span class="string">'p'</span>,<span class="string">'r'</span>)-2;
        line1 = 0;
        <span class="keyword">for</span> i = 1:3^state_card
            <span class="keyword">if</span> kk==1
                index_place = node_positions;
            <span class="keyword">else</span>
                index_place = node_positions + sum(state_count(1:kk-1));
            <span class="keyword">end</span>
            [no_inf] = inf_neighbors(k, states(i,:), sg{kk});
            <span class="keyword">if</span> line1 == 0 &amp;&amp; no_inf==1 &amp;&amp; states(i,k)==-1
                fprintf(fid, <span class="string">'T(%d) = tau*(y(%d)'</span>, [T_count i+index_place]);
                line1 = 1;
                T_count = T_count + 1;
            <span class="keyword">elseif</span> line1 == 1 &amp;&amp; no_inf==1 &amp;&amp; states(i,k)==-1
                fprintf(fid, <span class="string">' + y(%d)'</span>, i+index_place);
            <span class="keyword">elseif</span> no_inf&gt;0 &amp;&amp; states(i,k)==-1
                fprintf(fid, <span class="string">' +  %d*y(%d)'</span>, [no_inf i+index_place]);
            <span class="keyword">end</span>
            <span class="keyword">if</span> i== 3^state_card
                fprintf(fid,<span class="string">');\n'</span>);
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% The expected number of type-j hyperstubs infection will be</span>
<span class="comment">% exposed to upon infection of a node via any type of hyperstub is given by</span>
<span class="comment">% Delta(j), computed by the following:</span>
fprintf(fid,<span class="string">'Delta = T*delta; \n \n'</span>);

<span class="comment">% The following constructs a for' loop that defines the ODEs for the</span>
<span class="comment">% survivor functions (thetas):</span>
fprintf(fid, <span class="string">' for  j = 1:%d \n'</span>,node_positions);
fprintf(fid, <span class="string">'\t if PGF_Jacobian_1(j)==0 \n'</span>);
fprintf(fid, <span class="string">'\t\t dy(j) = 0; \n'</span>);
fprintf(fid, <span class="string">'\t else \n'</span>);
fprintf(fid, <span class="string">'\t\t dy(j) = -y(j)*T(j)/M(j); \n'</span>);
fprintf(fid, <span class="string">'\t end \n'</span>);
fprintf(fid, <span class="string">' end \n \n'</span>);

<span class="comment">% The following forms the ODEs for state transitions over subgraph</span>
<span class="comment">% types using the x_equations.m files. If the expected number of a subgraph</span>
<span class="comment">% type is zero it sets the corresponding ODEs to zero.</span>
<span class="keyword">for</span> i = 1:length(sg)
    <span class="keyword">if</span> i==1
        index_place     = node_positions+1;
        index_place_i   = node_positions+1;
    <span class="keyword">else</span>
        index_place   = index_place + length(sg{i-1});
        index_place_i   = index_place_i + 3^length(sg{i-1});
    <span class="keyword">end</span>
    EQ_name    = sprintf(<span class="string">'%s_equations'</span>,varargin{i});
    fprintf(fid, <span class="string">'if PGF_Jacobian_1(%d) == 0 \n'</span>, index_place-node_positions);
    fprintf(fid, <span class="string">'\t dy(%d:%d) = 0; \n'</span>, [index_place_i index_place_i-1+3^(length(sg{i}))]);
    fprintf(fid, <span class="string">'else \n'</span>);
    fprintf(fid, <span class="string">'\t [dy(%d:%d)] = %s'</span>,[index_place_i index_place_i-1+3^(length(sg{i})) EQ_name]);
    fprintf(fid, <span class="string">'(y(%d:%d)); \n'</span>,     [index_place_i index_place_i-1+3^(length(sg{i}))]);
    fprintf(fid, <span class="string">'end \n \n'</span>);
<span class="keyword">end</span>

<span class="comment">% ODE for I:</span>
fprintf(fid, <span class="string">'dy(end-1) = -dot(dy(%d:%d),PGF_Jacobian_theta(%d:%d)) - gamma*y(end-1); \n'</span>, [1 node_positions 1 node_positions]);
<span class="comment">% ODE for R:</span>
fprintf(fid, <span class="string">'dy(end) = gamma*y(end-1); \n'</span>);
fprintf(fid,<span class="string">'end'</span>);
fclose(fid);

<span class="comment">% options = odeset('AbsTol',1e-8,'RelTol',1e-8);</span>
<span class="comment">% [T,Y] = ode45(@func,[0 Tend],alpha,options);</span>
<span class="comment">% % I will always be the 2nd to last varibale</span>
<span class="comment">% I = Y(:,end-1);</span>
<span class="comment">% % R will always be the last.</span>
<span class="comment">% R = Y(:,end);</span>
<span class="comment">% S = 1 - I - R;</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><h2>State transition matrix generation<a name="8"></a></h2><pre class="codeinput"><span class="keyword">function</span> Z = trans_matrix(g,var_place,states)

<span class="comment">% Generates the transition matrix. A matrix that contains the rates of</span>
<span class="comment">% transition from one subgraph configuration to another.</span>
<span class="comment">% INPUT: g, subgraph adjacency matrix</span>
<span class="comment">% OUTPUT: A cell array with the {i,j}th entry corresponding the probability</span>
<span class="comment">% that state(i) transitions to state(j).</span>

nodes = length(g);
<span class="comment">% -1 = S</span>
<span class="comment">%  0 = I</span>
<span class="comment">%  1 = R</span>
card = length(states);
Z = cell(card);

<span class="keyword">for</span> i = 1:card
    <span class="keyword">for</span> k = 1:card
        <span class="keyword">if</span> i~=k
            no_inf_events = 0;
            no_rec_events = 0;

            <span class="keyword">for</span> j = 1:nodes;

                <span class="comment">% If an S -&gt; R, abort.</span>
                <span class="keyword">if</span>  states(i,j)==-1 &amp;&amp; states(k,j)==1
                    Z{i,k} =0;
                    <span class="keyword">break</span>
                <span class="keyword">end</span>

                <span class="comment">% If an I -&gt; S, abort.</span>
                <span class="keyword">if</span>  states(i,j)==0 &amp;&amp; states(k,j)==-1
                    Z{i,k} =0;
                    <span class="keyword">break</span>
                <span class="keyword">end</span>

                <span class="comment">% If an R changes, abort.</span>
                <span class="keyword">if</span> states(i,j)==1 &amp;&amp; states(k,j)~=1
                    Z{i,k} =0;
                    <span class="keyword">break</span>
                <span class="keyword">end</span>

                <span class="comment">% if S -&gt; I, find infectious pressure on S.</span>
                <span class="keyword">if</span> states(i,j) ==-1 &amp;&amp;  states(k,j)==0
                    no_inf_events = no_inf_events  +1;
                    no_inf = inf_neighbors(j, states(i,:), g);
                    <span class="keyword">if</span> no_inf~=0
                        Z{i,k} = sprintf(<span class="string">'%d*tau  + D(%d)/M(%d)'</span>,[no_inf j+var_place-1 j+var_place-1]);
                    <span class="keyword">else</span>
                        Z{i,k} = sprintf(<span class="string">'D(%d)/M(%d)'</span>,[j+var_place-1 j+var_place-1]);
                    <span class="keyword">end</span>
                <span class="keyword">end</span>

                <span class="comment">% If I -&gt; R, p(transition) = gamma</span>
                <span class="keyword">if</span> states(i,j) ==0 &amp;&amp;  states(k,j)==1
                    no_rec_events = no_rec_events + 1;
                    Z{i,k} = sprintf(<span class="string">'gamma'</span>);
                <span class="keyword">end</span>

                <span class="comment">% If more than one even happens, p = 0.</span>
                <span class="keyword">if</span> no_inf_events &gt; 1 || no_rec_events &gt; 1 || (no_inf_events + no_rec_events)&gt;1
                    Z{i,k} =0;
                    <span class="keyword">break</span>
                <span class="keyword">end</span>

            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2013a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% SIR-ODE generation for hyperstub configuration model networks
function PGF_equation_generator(lambda, varargin)
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
%                    http://arxiv.org/abs/1405.6234
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% The following code will generate generating function bassed,
% deterministic ODEs and corresponding solutions. The solutions include
% population level averages for the three respective compartments that may
% be compared to averages taken from simulation. Written by Martin Ritchie,
% University of Sussex, 2014.
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH output REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% lambda:   a vector containing the desired expected subgraph count per
%           node, lambda(i) corresponds to the ith varargin,
% varargin: Input is a string, where each string is the name assoicated the
%           desired subgraph. Separate different subgraphs names with
%           commas. Input subgraphs in the same order as thier given
%           expectations in lambda (example subgraphs are given in
%           subgraphs.mat).
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH- Generated files REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% x_alpha.m (one per subgraph type),
% x_equations.m (one per subgraph type),
% PGF_jacobian.m (one for the whole system)
% PGF_hessian.m (one for the whole system)
% func.m (one for the whole system)
%
% # dependencies: combinator.m, inf_neighbors.m, subgraphs.mat 
% and MATLAB's symbolic toolbox.
%% Example usage
% # The following will generate and solve ODEs for a Poisson random network
% with parameter, lambda = 4:
%
% PGF_equation_generator(4, 'C2');
% [S, I, R, T] = episolve();
% 
% Where 'C2' denotes a complete subgraph of two nodes, i.e. a line, that
% will be loaded from subgraphs.mat. Load subgraphs.mat to see what
% subgraphs are available or create your own. 
%
% # The following will generate and solve ODEs for a network where lines 
% and triangles are Poisson distributed with parameters, lambda = [2 2]
% respectively:
%
% PGF_equation_generator([2 2], 'C2', 'C3');
% [S, I, R, T] = episolve();
% Note that the epidemic parameters are controlled from within this
% function.
%% Initialisation
global eps tau gamma Tend PGF_Jacobian_1 sg node_positions alpha
load('subgraphs',varargin{:});
% Note that the epidemic parameters are controlled from within this
% function.
% eps: fraction of inital infected.
eps = 1/10000;
%
Tend = 15;
% tau: per link rate of infection.
tau = 1;
% gamma: rate of recovery.
gamma  = 1;
% node_positions: number of positions in the system.
node_positions = 0;
% sg: a cell array where each entry contains the adjacency matrix of the
%     subgraphs specified by varargin.
for i = 1:length(varargin)
    sg{i} = eval(varargin{i});
    node_positions = node_positions + length(sg{i});
end
%% PGF generation
% The following utilises MATLAB's symbolic toolbox. It symbolically
% generates and compute the Jacobian and Hessian of the PGF that generates
% the networks subgraph degree distribution. In this implementation each
% subgraph is Poisson distributed.
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH

%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH Standard Poisson PGF REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH

% The following generates the PGF.
X = sym('X', [1 node_positions]);
PGF = 1;
for i = 1:length(sg)
    m(i) = length(sg{i});
    PGF = PGF*exp(lambda(i)*m(i)^(-1) * (sum(X(1:m(i)))-m(i)));
    X(1:m(i)) = [];
end
X = sym('X', [1 node_positions]);

% It is inefficient to keep it in symbolic form. The following converts
% the symbolic forms of the Jacobian and Hessian of the PGF into MATLAB
% functions.

PGF_Jacobians = jacobian(PGF,X);
PGF_Hessians = hessian(PGF,X);
% Convert the symbolic Jacobian and Hessian to .m MATLAB functions.
matlabFunction(PGF_Hessians, 'file', 'PGF_Hessian','vars', X);
matlabFunction(PGF_Jacobians, 'file', 'PGF_Jacobian','vars', X);
clear PGF_Jacobians PGF_Hessians

% % state_count(i):    The number of states associated with subraph i.
% % subgraph_index(i): The first position index associated with each subgraph.
state_count = zeros(length(varargin),1);
subgraph_index = zeros(length(varargin),1);
for i = 1:length(varargin)
    if i ==1
        subgraph_index(i) = 1;
    else
        subgraph_index(i) = subgraph_index(i-1) + length(sg{i-1});
    end
    state_count(i) = 3^length(sg{i});
end
% The total number of ODEs:
system_size = (sum(state_count) + node_positions + 2);
% PGF_Jacobian_1: Jacobian of the PGF evaluated at 1.
in = num2cell(ones(1,node_positions));
PGF_Jacobian_1 = PGF_Jacobian(in{:});

%% Code generation
% The following generates three different m-files:
% # x_alpha.m: a function file that returns initial conditions for the
% subgraph x,
% # x_equations: a function file that returns state equations for the
% subgraph x,
% # func.m: the function that is passed to ODE45 for integration.
% alpha: is a vector of initial conditions that is eventually passed to
% ode 45. It needs to be initialised outside of the following loop, within
% which the remaining initial conditions are generated and appended to alpha.
alpha = zeros(1,(node_positions));
% Survivor function (theta) initial conditions:
for i = 1:node_positions
    if PGF_Jacobian_1(i)~=0
        alpha(i) = 1;
    end
end

% ii cycles through each subgraph generating x_equations.m followed by
% x_alpha.m
for ii = 1:length(varargin)
    % states: a matrix containing all possible states of g.
    states = combinator(3,length(sg{ii}),'p','r')-2;
    % trans_matrix: creates the state transition matrix for g.
    transition_matrix = trans_matrix(sg{ii},subgraph_index(ii),states);
    
    % the following creates a matlab function file that corresponds to
    % the state equations for subgraph g.
    flux_name = sprintf('%s_equations.m',varargin{ii});
    fid = fopen(flux_name,'w');
    ltm = length(transition_matrix);
    fprintf(fid,'function [dy] = %s_equations(y) \n \n global tau gamma Delta M \n D = Delta; \n \n ',varargin{ii});
    for i = 1:ltm
        for k = 1:length(sg{ii})
            switch states(i,k)
                case -1
                    s(k) = 'S';
                case 0
                    s(k) = 'I';
                case 1
                    s(k) = 'R';
            end
        end
        fprintf(fid, '  %% %s \n ', s);
        fprintf(fid,'dy(%d) = ', i);
        for j = 1:ltm
            if ~isempty(transition_matrix{i,j})
                if transition_matrix{i,j}~=0
                    fprintf(fid,' - y(%d)*(%s)', [i transition_matrix{i,j}]);
                end
            end
            if ~isempty(transition_matrix{j,i})
                if transition_matrix{j,i}~=0
                    fprintf(fid,' + y(%d)*(%s)', [j transition_matrix{j,i}]);
                end
            end
            
        end
        fprintf(fid,';\n \n');
    end
    fprintf(fid,'end');
    fclose(fid);
    
    % Initial conditions: the following generates x_alpha.m, a matlab
    % function file that returns a vector of initial conditions for subgraph
    % x.
    
    alpha_name = sprintf('%s_alpha.m',varargin{ii});
    fid = fopen(alpha_name,'w');
    ltm = length(transition_matrix);
    fprintf(fid,'function [initial] = %s_alpha \n \n global eps PGF_Jacobian_1 \n',varargin{ii});
    fprintf(fid,'initial = zeros(1,%d); \n', ltm);
    fprintf(fid,'if PGF_Jacobian_1(%d)==0 \n', subgraph_index(ii));
    fprintf(fid,'\t return \n');
    fprintf(fid, 'else \n');
    for i = 1:ltm
        if isempty(find(states(i,:)==1))
            s_count = 0;
            i_count = 0;
            r_count = 0;
            for k = 1:length(sg{ii})
                switch states(i,k)
                    case -1
                        s_count = s_count + 1;
                    case 0
                        i_count = i_count + 1;
                    case 1
                        r_count = r_count + 1;
                end
            end
            
            if s_count == length(sg{ii})
                fprintf(fid,'initial(%d) = (1-eps)*PGF_Jacobian_1(%d); \n', [i subgraph_index(ii)]);
            elseif i_count >= 2
                fprintf(fid,'initial(%d) = 0; \n', i);
            elseif i_count == 1
                fprintf(fid,'initial(%d) = eps*PGF_Jacobian_1(%d); \n', [i subgraph_index(ii)]);
            else
                fprintf(fid,'initial(%d) =0; \n', [i]);
            end
            
        end
    end
    fprintf(fid, 'end \n');
    fprintf(fid,'end');
    fclose(fid);
    innit_name{ii} = sprintf('%s_alpha',varargin{ii});
    alpha(end+1:end + 3^length(sg{ii})) = feval(innit_name{ii});
end
% I_0
alpha(end+1) = eps;
% R_0
alpha(end+1) = 0;




% Generation of func.m: func.m is the ODE function that is passed to ODE45
% along with the vector of initial conditions, 'alpha'.
fid=fopen('func.m','w');
fprintf(fid,'function dy = func(~,y) \n \n');
fprintf(fid,'global tau gamma Delta M PGF_Jacobian_1 \n');
fprintf(fid,'T  = zeros(1,%d); \n ',node_positions);
fprintf(fid,'dy = zeros(%d,1); \n \n',system_size);

for i = 1:node_positions
    if i==1
        fprintf(fid, 'PGF_Jacobian_theta  = PGF_Jacobian(y(%d),', i);
    elseif i==node_positions
        fprintf(fid, 'y(%d)); \n', i);
    else
        fprintf(fid, 'y(%d),', i);
    end
end
for i = 1:node_positions
    if i==1
        fprintf(fid, 'PGF_Hessian_theta  = PGF_Hessian(y(%d),', i);
    elseif i==node_positions
        fprintf(fid, 'y(%d)); \n', i);
    else
        fprintf(fid, 'y(%d),', i);
    end
end
% For loop that generates susceptible excess degree matrix, delta:
fprintf(fid, 'for i = 1:%d \n', node_positions);
fprintf(fid, ' \t M(i) = y(i)*PGF_Jacobian_theta(i); \n');
fprintf(fid, '\t for  j = 1:%d \n',node_positions);
fprintf(fid, '\t\t if PGF_Jacobian_theta(i)==0 \n');
fprintf(fid, '\t\t\t delta(i,j)=0; \n');
fprintf(fid, '\t\t else \n');
fprintf(fid, '\t\t\t delta(i,j) = y(j)*PGF_Hessian_theta(i,j)/PGF_Jacobian_theta(i); \n');
fprintf(fid, '\t\t end \n');
fprintf(fid, '\t end \n');
fprintf(fid, ' end \n');

% T(i) contains the rate of infection received by node i. The following
% generates T(i) for each corner. If there are 2 graplets composed of a
% total of 10 corners then dim(T) = [1, 10].
T_count = 1;
for kk = 1:length(sg)
    if kk==3
        kk = 3;
    end
    state_card = length(sg{kk});
    for k = 1:state_card
        states = combinator(3,length(sg{kk}),'p','r')-2;
        line1 = 0;
        for i = 1:3^state_card
            if kk==1
                index_place = node_positions;
            else
                index_place = node_positions + sum(state_count(1:kk-1));
            end
            [no_inf] = inf_neighbors(k, states(i,:), sg{kk});
            if line1 == 0 && no_inf==1 && states(i,k)==-1
                fprintf(fid, 'T(%d) = tau*(y(%d)', [T_count i+index_place]);
                line1 = 1;
                T_count = T_count + 1;
            elseif line1 == 1 && no_inf==1 && states(i,k)==-1
                fprintf(fid, ' + y(%d)', i+index_place);
            elseif no_inf>0 && states(i,k)==-1
                fprintf(fid, ' +  %d*y(%d)', [no_inf i+index_place]);
            end
            if i== 3^state_card
                fprintf(fid,');\n');
            end
        end
    end
end

% The expected number of type-j hyperstubs infection will be
% exposed to upon infection of a node via any type of hyperstub is given by
% Delta(j), computed by the following:
fprintf(fid,'Delta = T*delta; \n \n');

% The following constructs a for' loop that defines the ODEs for the
% survivor functions (thetas):
fprintf(fid, ' for  j = 1:%d \n',node_positions);
fprintf(fid, '\t if PGF_Jacobian_1(j)==0 \n');
fprintf(fid, '\t\t dy(j) = 0; \n');
fprintf(fid, '\t else \n');
fprintf(fid, '\t\t dy(j) = -y(j)*T(j)/M(j); \n');
fprintf(fid, '\t end \n');
fprintf(fid, ' end \n \n');

% The following forms the ODEs for state transitions over subgraph
% types using the x_equations.m files. If the expected number of a subgraph
% type is zero it sets the corresponding ODEs to zero.
for i = 1:length(sg)
    if i==1
        index_place     = node_positions+1;
        index_place_i   = node_positions+1;
    else
        index_place   = index_place + length(sg{i-1});
        index_place_i   = index_place_i + 3^length(sg{i-1});
    end
    EQ_name    = sprintf('%s_equations',varargin{i});
    fprintf(fid, 'if PGF_Jacobian_1(%d) == 0 \n', index_place-node_positions);
    fprintf(fid, '\t dy(%d:%d) = 0; \n', [index_place_i index_place_i-1+3^(length(sg{i}))]);
    fprintf(fid, 'else \n');
    fprintf(fid, '\t [dy(%d:%d)] = %s',[index_place_i index_place_i-1+3^(length(sg{i})) EQ_name]);
    fprintf(fid, '(y(%d:%d)); \n',     [index_place_i index_place_i-1+3^(length(sg{i}))]);
    fprintf(fid, 'end \n \n');
end

% ODE for I:
fprintf(fid, 'dy(end-1) = -dot(dy(%d:%d),PGF_Jacobian_theta(%d:%d)) - gamma*y(end-1); \n', [1 node_positions 1 node_positions]);
% ODE for R:
fprintf(fid, 'dy(end) = gamma*y(end-1); \n');
fprintf(fid,'end');
fclose(fid);

% options = odeset('AbsTol',1e-8,'RelTol',1e-8);
% [T,Y] = ode45(@func,[0 Tend],alpha,options);
% % I will always be the 2nd to last varibale
% I = Y(:,end-1);
% % R will always be the last.
% R = Y(:,end);
% S = 1 - I - R;

end
%% State transition matrix generation
function Z = trans_matrix(g,var_place,states)

% Generates the transition matrix. A matrix that contains the rates of
% transition from one subgraph configuration to another.
% INPUT: g, subgraph adjacency matrix
% OUTPUT: A cell array with the {i,j}th entry corresponding the probability
% that state(i) transitions to state(j).

nodes = length(g);
% -1 = S
%  0 = I
%  1 = R
card = length(states);
Z = cell(card);

for i = 1:card
    for k = 1:card
        if i~=k
            no_inf_events = 0;
            no_rec_events = 0;
            
            for j = 1:nodes;
                
                % If an S -> R, abort.
                if  states(i,j)==-1 && states(k,j)==1
                    Z{i,k} =0;
                    break
                end
                
                % If an I -> S, abort.
                if  states(i,j)==0 && states(k,j)==-1
                    Z{i,k} =0;
                    break
                end
                
                % If an R changes, abort.
                if states(i,j)==1 && states(k,j)~=1
                    Z{i,k} =0;
                    break
                end
                
                % if S -> I, find infectious pressure on S.
                if states(i,j) ==-1 &&  states(k,j)==0
                    no_inf_events = no_inf_events  +1;
                    no_inf = inf_neighbors(j, states(i,:), g);
                    if no_inf~=0
                        Z{i,k} = sprintf('%d*tau  + D(%d)/M(%d)',[no_inf j+var_place-1 j+var_place-1]);
                    else
                        Z{i,k} = sprintf('D(%d)/M(%d)',[j+var_place-1 j+var_place-1]);
                    end
                end
                
                % If I -> R, p(transition) = gamma
                if states(i,j) ==0 &&  states(k,j)==1
                    no_rec_events = no_rec_events + 1;
                    Z{i,k} = sprintf('gamma');
                end
                
                % If more than one even happens, p = 0.
                if no_inf_events > 1 || no_rec_events > 1 || (no_inf_events + no_rec_events)>1
                    Z{i,k} =0;
                    break
                end
                
            end
        end
    end
end
end
##### SOURCE END #####
--></body></html>